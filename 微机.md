# 微机笔记
# 目录
>   * [1.8086的寻址方法和指令系统](#1)
>   * [2.8086的寻址方法和指令系统](#2)
>      * 1.1
>   * [3.8086的寻址方法和指令系统](#3)
>      * [3.1 8086寻址方式](#31)
>      * [3.2 8086寻址方式](#32)
<h2 id=1> 1.矢量与场论</h2>

>* [1.1正交坐标系与矢量](#11)
>* [1.2正交坐标系与矢量](#12)
<h2 id=3> 3.8086的寻址方法和指令系统</h2>

>* [3.1 8086寻址方式](#31)
>* [3.2 8086指令系统](#32)
### <w id=31>3.1 8086寻址方式
#### 四种指令存放方式
>1. **四种指令存放方式**
><img src="pic/指令存放方式.png" style="zoom:50%">
><font color=#ff0000>其中内存实际地址构成：存储单元所在段的基地址/>段内偏移地址（偏移量）</font>
>2. **段内偏移地址EA也就是有效地址**
>       * 基址寄存器内容
>       * 变址寄存器内容
>       * 比例因子
>       * 位移量
><font color=#ff0000>EA=基址+(变值×比例因子)+位移量</font>
>3. **对于实模式（16位寻址）：**
>       * 基址寄存器：BX，BP
>       * 变址寄存器：SI，DI
>       * 比例因子：0，1
>       * 位移量：0，8，16位
#### 各种寻址方式
>1. **立即寻址**
>2. **寄存器寻址**
>3. **直接寻址：**
>MOV AL,DS:[2000H] (没有默认在DS,如果在其他就称段超越)
>4. **间接寻址：上面的偏移量放在了寄存器里**
>1. **基址寻址：MOV EAX,[基址寄存器]+24，这个24基本上放哪都行**
>BX(默认段寄存器为DS)，BS(默认段寄存器为SS)是基址寄存器
>EA=DS<<16+BX+24
>EA=SS<<16+BP+24
>1. **变址寻址：MOV EAX,[变址寄存器]+24，这个24基本上放哪都行**
>SI，DI(默认段寄存器为DS)是变址寄存器
>EA=DS<<16+BX+24
>EA=SS<<16+BP+24
>1. **基址变址寻址：MOV EAX,[基址寄存器+变址寄存器]，这个24基本上放哪都行**
>1. **带位移的基址变址寻址：MOV EAX,[基址寄存器+变址寄存器]，这个24基本上放哪都行**
>[BX][SI]=[BX]+SI=SI[BX]
<img src="pic/默认段.png" style="zoom:50%">

### <w id=32>3.2 8086指令系统
<img src="pic/指令系统.png" style="zoom:50%">

#### 数据传送类 
>1. **堆栈操作数指令栈底是最高位**
>1. **SS和SP**
>    * **物理地址**=SS<<16到SS<<16+SP;
>    * **出栈sp++**
>    * **入栈sp--**
>    * **交换指令**  
>1. **交换指令**：段寄存器和立即数不能作为操作数
>4. **查表指令:** XLAT **表头变量名字**
>1. **LEA 16位目标寄存器如AX,[16位源操作地址]**
>2. **LDS/LES 8位目标寄存器如AL,[16位源操作地址]**
>高字节存在DS或者ES中了
>1. **LAHF** 读标志寄存器送到AH
>2. **LAHF** AH写入标志寄存器的低位
>3. **PUSHF**标志寄存器的内容推入对堆栈然后sp-=2
>4. **PUPF**取出堆栈顶内容然后sp+=2，标志寄存器的内容
>
>I/O数据传送指令
>1. **IN 累加器（AX），端口 号**
>2. **OUT 端口号，累加器（AX）**
>3. **端口号大于8位需要先move到DX再IN AX DX**
>4. **I/O端口编址方式**
>    1. 独立编址
>          * 优点：不占用内存地址，不减少存储器空间，I/O指令短，速度 快，能直接区分访问的是存储器还是外设，可读性好。 控制译 码电路简单。
>          * 缺点：只能对端口进行操作，不能进行其他运行处理。 
>    2. 统一编址
>          * 优点：系统结构简单，无需I/O专用指令，端口的寻址手段丰富，并 可进行相应的操作处理。 
>          * 缺点：程序的可读性差,且需要占用存储器的空间。

#### 算数运算指令
>1. **加法指令**
>    * ADD **目标**，**源**
>    源操作数+目标->目标
>    * ADC **目标**，**源**
>    源操作数+目标+CF->目标 <font color=#ff0000>CF是上一级的进位</font>
>    * INC **目标** <font color=#ff0000>累加，用于循环</font>
>    * of=0有符号数溢出判断
>    * cf=0无符号数溢出判断
>    源操作数+1->目标
>2. **减法指令** 
>    * SUB **目标操作数**，**源操作数**
>        * 目标-源操作数->目标
>        * 需要都是带符号或无符号，目标只能是寄存器或存储器，不能是立即数
>        * 补码无进位，表示有借位
>    * SBB **目标操作数**，**源操作数**
>        * 目标-源操作数-cf->目标 <font color=#ff0000>借位</font>
>    * DEC **目标操作数**  <font color=#ff0000>自减</font>
>    * NEG **目标操作数**  <font color=#ff0000>取反</font>
>    * CMP **目标操作数1**，**源操作数2**
>         * ZF=1：两数相等
>         * 无符号数：CF1=1则1<2
>         * 有符号数：0F1=1则1<2
>         * 小为1
>3. **乘法指令** 
>    * 无符号 MUL OPRD
>    * 有符号 IMUL OPRD
>    * 若操作数是AL，结果存在AX中
>    * 若是字乘法AX，结果搞16位放在DX，低16位在AX
>4. **除法指令** 
>    * DIV 除数  无符号数
>    * IDIV 除数 无符号数
>    * AX为被除数，商在AL，余数在AH
>    * 要求被除数是除数长度的两倍，如果被除数和除数长度相同则需要拓展被除数
>    * CBW 字节拓展
>    * CWD 字拓展
>5. **关注点：运算方式，操作数个数，默认的源和目标**
<h4>逻辑运算与移位指令</h4>

>1. **位运算**
><img src="pic/位运算.png" style="zoom:70%">
>
>2. **位测试**
>    * TEST OPRD1 OPRD2（一般是一位）
>    * 两个与一下，ZF=1则0，反之
>3. **移位操作**
>    <img src="pic/移位操作.png" style="zoom:50%">
>    <img src="pic/位运算图.png" style="zoom:50%">
>   * A是算数移位，要保证
>
>
>
>
>

